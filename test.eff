let c = new ref (* Because choice is not builtin *)
in

let fail = new ref (* Because choice is not builtin *)
in

let rec filter p = function
  | [] -> []
  | x :: xs ->
    if p x then (x :: filter p xs) else filter p xs
in

let rec forall p = function
  | [] -> true
  | x :: xs -> if p x then forall p xs else false
in

let no_attack (x, y) (x', y') =
  x <> x' && y <> y' && abs (x - x') <> abs (y - y')
in

let available x qs =
  filter (fun y -> forall (no_attack (x, y)) qs) [1; 2; 3; 4; 5; 6; 7; 8]
in

 
let rec choose xs =
  match xs with
  | [] -> raise fail ()
  | x :: xs -> if c#decide () then x else choose xs
in

let rec place x qs =
  if x = 9 then qs else
  let y = choose (available x qs) in
  place (x + 1) ((x, y) :: qs)
in

let dont_fail = handler
| c#decide () k ->
    handle k true with
    | fail#raise () _ -> k false
in

with dont_fail handle
  place 1 []
