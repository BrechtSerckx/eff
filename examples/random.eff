type 'a random = effect
  operation pick : ('a * float) list -> 'a
end

let uniform lst =
  let n = length lst in
    map (fun x -> (x, 1.0 /. float n)) lst ;;

let combine =
  let scale p xs = map (fun (i, x) -> (i, p *. x)) xs in
  let rec add (i,x) = function
    | [] -> [(i,x)]
    | (j,y)::lst ->
      if i = j then (j, x +. y) :: lst else (j,y) :: add (i,x) lst
  in
    fold_left (fun e (d,p) -> fold_right add (scale p d) e) [] ;;

let distribution r = handler
  | val v -> [(v, 1.0)]
  | r#pick lst k ->
      combine (map (fun (x,p) -> (k x, p)) lst) ;;

let expectation r = handler
  | val v -> v
  | r#pick lst k ->
      fold_right (fun (x,p) e -> e +. p *. k x) lst 0.0 ;;

check_val (
  let r = new random in
  with expectation r handle
    let a = r#pick (uniform [1.0; 2.0; 4.0]) in
      a
) ;;

check_val (
let r = new random in
with distribution r handle
  let a = r#pick (uniform [1;2;3;4;5;6]) in
  let b = r#pick (uniform [1;2;3;4;5;6]) in
    a + b
) ;;

check_val (
let r = new random in
with expectation r handle
  let rec walk x n =
    if n = 0 then x else
      let d = r#pick [(-1, 0.2); (0, 0.3); (1, 0.5)] in
        walk (x + d) (n - 1)
  in
    float (walk 0 5)
) ;;

check_val (
let r = new random in
with distribution r handle
  let rec walk x n =
    if n = 0 then x else
      let d = r#pick [(-1, 0.2); (0, 0.3); (1, 0.5)] in
        walk (x + d) (n - 1)
  in
    walk 0 5
) ;;

let state r x = handler
  | val y -> (fun s -> y)
  | r#lookup () k -> (fun s -> k s s)
  | r#update s' k -> (fun s -> k () s')
  | finally f -> f x ;;

print_string "WHY DOES THIS ONE WORK?\n"; 
check_val (
let r = new random in
with distribution r handle
  let x = new ref in
  with state x 0 handle
    for i = 1 to 5 do
      x := !x + r#pick [(-1, 0.2); (0, 0.3); (1, 0.5)]
    done;
    !x
) ;;

print_string "EXPECTED VALUE FOR 7 STEPS";
check_val (
let r = new random in
with expectation r handle
  let x = new ref in
  with state x 0 handle
    for i = 1 to 7 do
      x := !x + r#pick [(-1, 0.2); (0, 0.3); (1, 0.5)]
    done;
    float (!x)
) ;;

check_val (
let r = new random in
with distribution r handle
  let x = new ref in
  with state x 0 handle
    for i = 1 to 5 do
      x := !x + r#pick [(-1, 0.2); (0, 0.3); (1, 0.5)]
    done;
    !x
) ;;