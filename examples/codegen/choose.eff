effect Decide : unit -> bool;;
effect Fail : unit -> empty;;

let rec choose =
  function
  | [] -> absurd (#Fail ())
  | x::xs -> if #Decide () then x else choose xs

let backtrack = handler
| #Decide () k ->
    handle k true with
    | #Fail () _ -> k false

let choose_all =
    handler
    | val x -> [x]
    | #Decide () k -> k true @ k false
    | #Fail _ _ -> []

;;

let no_attack (x,y) (x',y') =
  x <> x' && y <> y' && abs (x - x') <> abs (y - y');;

let available x qs =
  filter (fun y -> forall (no_attack (x,y)) qs) [1;2;3;4;5;6;7;8]

;;


(* This one finds [(8, 4); (7, 2); (6, 7); (5, 3); (4, 6); (3, 8); (2, 5); (1, 1)]. *)
with backtrack handle
  let rec place x qs =
    if x = 9 then qs else
      let y = choose (available x qs) in
      place (x+1) ((x, y) :: qs)
  in place 1 []

;;

(* This one finds all the solutions. *)
with choose_all handle
  let rec place x qs =
    if x = 9 then qs else
      let y = choose (available x qs) in
      place (x+1) ((x, y) :: qs)
  in place 1 []

;;

