# Gordon's idea for interleaving handler
type 'a process = effect
  operation nil: unit -> empty
  operation choose: unit -> bool
  operation action: 'a -> unit
end ;;

let p = new process ;;

let sum x y = if p#choose () then x else y ;;

let mr_proceed a = handler
  | p#action b k ->
      toplevel#print b;
      let (_, proceed) = k () in
        (
            (fun f ->
                if a = b then
                    p#action a;
                    f (proceed ())
                else
                    toplevel#print "Here";
                    absurd (p#nil
                    ())
            ),
            (fun () ->
                p#action b;
                proceed ()
            )
        )
  | val _ ->
        (
            (fun _ -> absurd (p#nil ())),
            (fun _ -> absurd (p#nil ()))
        )

let m = handler
  | p#action a k ->
      fun z ->
        let (mr, _) = with mr_proceed a handle z () in
        mr (k ())
  | val _ ->
      toplevel#print "Everywhere";
      absurd (p#nil ())

let p1 () =
    p#action "a";
    p#action "b";
    p#nil ()

let p2 () =
    p#action "a";
    p#action "c";
    p#nil () ;;

handle
    (with m handle p1 ()) p2
with
| p#action a k -> toplevel#print a; k ()




(* # trying to do Levy's interleaving idea. Does not work yet, though.

type Process:
    operation output : Integer -> ()
    operation choose : () -> Bool
    operation stop : () -> ()

type Proc x:
  case Act (Integer, Proc x)
  case Or (Proc x, Proc x)
  case Nil
  case Ret x

reify p = handler:
  operation p.output a:
    x = yield ()
    Act (a, x)
  operation p.choose _:
    x1 = yield True
    x2 = yield False
    Or (x1, x2)
  operation p.stop _:
    Nil
  return x:
    Ret x


check:
  p = new Process
  def act a t ():
    p.output a
    t ()
  def or t1 t2 ():
    if p.choose (): t1 ()
    else: t2 ()
  def nil ():
    p.stop ()
  def unit ():
    ()
  handle with reify p:
    t1 = act 1 (or (act 2 nil) (act 3 unit))
    t2 = act 4 (or (act 5 nil) (act 6 nil))
    t1 ()


  # with:
  #   operation output a:
  #     y = yield
  #     lambda u:
  #       output q a
  #       match choose q ():
  #         case Left: y () u
  #         case Right:
  #           with:
  #             operation output b:
  #               z = yield
  #               output q b
  #               match choose q ():
  #                 case Left: z ()
  #                 case Right: y () z
  #           handle q:
  #             u
  #   finally f: f t2
  # handle q:
  #   t1 ()
 *)