(* Martin Escardo's search functionals. *)

type 'a result = Failure | Success of 'a

type ('a, 'b) selection = effect
  operation select: 'a * 'b list -> 'b
end

let select s v = handler
  | s#select (x,ys) k -> (fun cs ->
    (match assoc x cs with
     | Some y -> k y cs
     | None ->
         let rec try = function
           | [] -> Failure
           | y::ys ->
               (match k y ((x,y)::cs) with
                  | Success lst -> Success lst
                  | Failure -> try ys)
         in try ys))
  | val u -> (fun cs ->
      if u = v then Success cs else Failure)
  | finally f -> f [] ;;

check_val (
  let s = new selection in
  with select s true handle
    let a = s#select ("a", [5;6;7;8]) in
    let b = s#select ("b", [9;10;11;12]) in
    let c = s#select ("c", [13;14;15;16]) in
      a*a + b*b = c*c
) ;;

(* Martin Escardo's epsilon. *)

let epsilon p =
  let s = new selection in
  let r = (with select s true handle
             p (fun n -> s#select (n, [false; true])))
  in
    match r with
      | Failure -> (fun _ -> false)
      | Success lst ->
        (fun n -> match assoc n lst with
                  | None -> false | Some b -> b)
;;

#type epsilon ;;

check_val (
  let b = epsilon (fun a -> a 0 <> a 1 && a 1 <> a 2 && a 2 <> a 3) in
  take b 10
) ;;

check_val (
  let b = epsilon (fun a -> a 0 && not (a 0)) in
  take b 10
)
