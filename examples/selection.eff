type 'a choice =
    effect
      operation guess : unit -> 'a
    end

let rec assoc x lst =
  match lst with
    | [] -> None
    | (x',y) :: lst ->
        if x = x' then Some y else assoc x lst

let assoc2fun y0 lst x =
  match assoc x lst with
    | None -> y0
    | Some y -> y

type ('a, 'r) selector = { x : 'a ; h : 'a choice -> ('r => 'a * 'r) }

let epsilon {h=h} p =
  let c = new choice in
    fst (with h c handle p (c#guess ()))

let quantify {h=h} p =
  let c = new choice in
    snd (with h c handle p (c#guess ()))

(* A selector which finds an argument in the list xs for which the result will be z. *)
let find_arg xs z =
  let (x::xs) = xs in
    { x = x;
      h = (fun c -> handler
      | c#guess () k ->
          let rec loop us =
            (match us with
               | [] -> let (_, y) = k x in (x, y)
               | u::us ->
                   let (_, y) = k u in
                     if y = z then (u, y) else loop us)
          in
            loop xs
      | val y -> (x, y)) }

let bool = find_arg [false; true] true

let state r x = handler
  | val y -> (fun s -> (y, s))
  | r#lookup () k -> (fun s -> k s s)
  | r#update s' k -> (fun s -> k () s')
  | finally f -> f x ;;

(* let otimes {x=x1;h=h1} {x=x2;h=h2} =
  { x = (x1,x2) ;
    h = (fun c ->
           handler
             | c#guess () k ->
                 let a = new ref in
                 let b = new ref in
                   with state a x1 handle
                   with state b x2 handle
                     let c1 = new choice in
                     let c2 = new choice in
                     let r = snd (with h1 c1 handle
                             snd (with h2 c2 handle
                                    a#update (c1#guess ()) ;
                                    b#update (c2#guess ()) ;
                                     snd (k (a#lookup(), b#lookup()))
                                 ))
                     in
                       ((a#lookup(), b#lookup()), r)
             | val v -> ((x1,x2), v))
  }
 *)
type ('a, 'b) memo = effect
                       operation put : ('a * 'b) -> unit
                       operation get : 'a -> ('b option)
                     end

let memoizer m = handler
  | m#get x k -> (fun lst -> k (assoc x lst) lst)
  | m#put (x,y) k -> (fun lst -> k () ((x,y) :: lst))
  | val v -> (fun lst -> (lst, v))
  | finally f -> f []

type ('a,'b) selector' =
  effect
    operation predict : 'a -> 'b
  end
     
let opower {x=x; h=h} =
  { x = (fun _ -> x) ;
    h = (fun c ->
           handler
             | c#guess () k ->
                 let m = new memo in
                 let d = new selector' in
                   with memoizer m handle
                     (handle
                        snd (k d#predict)
                      with
                        | d#predict u l ->
                            (match m#get u with
                               | Some v -> l v
                               | None ->
                                   let d = new choice in
                                   let (v,r) = (with h d handle l (d#guess ())) in
                                     m#put (u,v) ;
                                     r))
             | val v -> ([], v)
             | finally (lst, v) -> (assoc2fun x lst, v)
        )
  }

let s n a =
  let rec l b n a =
    match n with
      | 0 -> b
      | n -> if (a 0)
             then l false (n-1) (fun i -> a (3 * i + 1))
             else l b (n-1) (fun i -> a (3 * i + 2))
  in
    l true n a
