(* List reversal using store. We would like this to be a polymorphic function. *)

let rev lst =
  let s = ref lst in
  let t = ref [] in
    (while !s <> [] do
       match !s with
       | [] -> assert false
       | x::xs -> s := xs ; t := (x :: !t)
     done) ;
     !t ;;

type 'a linked = Nil | Cons of 'a * 'a linked store ;;

let linked_rev r =
  let rec rev prev = function
    | Nil -> prev
    | Cons (x, r) as current  ->
      let next = !r in
        r := prev ;
        rev current next
  in
    r := rev Nil (!r) ;;

let rec to_list = function
  | Nil -> []
  | Cons (a, r) -> a :: (to_list (!r))

(* example *)
let foo = ref (Cons (1, ref (Cons (2, ref (Cons (3, ref Nil)))))) ;;
