{"name":"Eff","tagline":"A functional programming language based on algebraic effects and their handlers.","body":"Eff\r\n===\r\n\r\nEff is a functional programming language based on algebraic effects and\r\ntheir handlers.\r\n\r\nAlgebraic effects are a way of adding computational effects to a pure\r\nfunctional setting. In a technical sense they are subsumed by the monadic\r\napproach to computational effects, but they offer new ways of programming\r\nthat are not easily achieved with monads. In particular, algebraic effects\r\nare combined seamlessly, whereas monad transformers are needed in the\r\nmonadic style.\r\n\r\nThe main idea of eff is that computational effects are accessed through a\r\nset of operations, for example `lookup` and `update` for state, `read` and\r\n`write` for I/O, `raise` for exceptions, etc. The behavior of operations is\r\ndetermined by handlers. Just like an exception handler determines what\r\nhappens when an exception is raised, a general handler describes the\r\nactions taken when an operation is triggered. Examples of handlers include\r\nstate, transactions, non-determinism, stream redirection, backtracking,\r\ndelimited continuations, and many others.\r\n\r\nBecause eff supports first-class effects and handlers, programmers may\r\ndefine new computational effects, combine existing ones, and handle effects\r\nin novel ways. For instance, ML-style references are a defined concept in\r\neff.\r\n\r\nEff code looks and feels like that of Ocaml because eff uses Ocaml syntax\r\nextended with constructs for effects and handlers. Furthermore, eff is a\r\nstatically typed language with parametric polymorphism and type inference.\r\nThe types are similar to those of OCaml and other variants of ML in the\r\nsense that they do not express any information about computational effects.\r\n\r\nFor further information visit the [eff page](http://math.andrej.com/eff/)\r\nor contact the authors Andrej Bauer <Andrej.Bauer@andrej.com> and Matija\r\nPretnar <matija@pretnar.info>.\r\n\r\nObtaining eff\r\n-------------\r\n\r\n### Prerequisites\r\n\r\nWe have tested eff on Mac OS X and Linux, and it should work in other\r\nUnix-like environments. In principle, nothing prevents eff from running\r\non Windows, we just have not tested it yet.\r\n\r\nTo install eff, you need a standard Unix-style build environment as well as\r\n\r\n1. [OCaml](http://caml.inria.fr/ocaml/), version 3.12 or newer, and\r\n2. [Menhir](http://cristal.inria.fr/~fpottier/menhir/) parser generator\r\n\r\nWe do not require, but recommend a command-line editing wrapper such as\r\n[rlwrap](http://utopia.knoware.nl/~hlub/rlwrap/#rlwrap) or\r\n[ledit](http://cristal.inria.fr/~ddr/ledit/). Eff uses these automatically.\r\n   \r\n\r\n### Compilation\r\n\r\nTo compile eff, first run\r\n\r\n    ./configure\r\n\r\nIf it complains you will have to install missing prerequisites. The\r\nconfiguration script takes standard GNU Autoconf arguments, such as\r\n`--prefix` which determines where to install eff. Type `./configure --help`\r\nfor more information. Next, run\r\n\r\n    make\r\n\r\nIf all goes well, you should be able to run eff in-place by typing `./eff`.\r\n\r\nYou can also run a battery of tests with\r\n\r\n    make test\r\n\r\n### Installation\r\n\r\nTo install the command `eff`, run\r\n\r\n    sudo make install\r\n\r\nSee the file `etc/README.txt` for editor support.\r\n\r\nCopyright and license\r\n---------------------\r\n\r\nCopyright (c) 2012, Andrej Bauer and Matija Pretnar\r\nCopyright (c) 2012, Timotej Lazar\r\n\r\nEff is distributed under the abbreviated BSD License, see `LICENSE.txt` for\r\nlicensing information.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}