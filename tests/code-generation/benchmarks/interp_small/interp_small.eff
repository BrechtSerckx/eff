

let absurd void = match void with;;
external ( = ) : 'a -> 'a -> bool = "="
external ( + ) : int -> int -> int = "+"
external ( * ) : int -> int -> int = "*"
external ( - ) : int -> int -> int = "-"
external ( ~-) : int -> int = "~-"
external ( / ) : int -> int -> int = "/"
let rec (@) xs ys =
  match xs with
  | [] -> ys
  | x :: xs -> x :: (xs @ ys)

(***********************************
******* The Building Blocks ********
***********************************)

(********************************
* Types
********************************)

type num = int;;
type func = int -> int;;
type loc = int;;
type name = string;;
type env = (string * int) list;;

type term =
    | Num of int
    | Add of (term * term)
    | Mul of (term * term)
    | Sub of (term * term)
    | Div of (term * term)
;;

(********************************
* Effects
********************************)

(* Main variable not found exception *)
effect VarNotFound : unit -> empty;;

(* Error handling *)
(* effect Err : string -> int;; *)
effect Arith_DivByZero : unit -> int;;



(********************************
* Main interpreter method
********************************)


let rec interp a =
    begin match a with
    | Num b -> b
    | Add (l, r) -> let x = (interp l) in
                    let y = (interp r) in 
                    x + y
    | Mul (l, r) -> let x = (interp l) in
                    let y = (interp r) in 
                    x * y
    | Sub (l, r) -> let x = (interp l) in
                    let y = (interp r) in 
                    x - y 

    | Div (l, r) -> let r_num = (interp r) in
                    let l_num = (interp l) in 
               begin match r_num with
                | 0 -> #Arith_DivByZero ()
                | _ -> l_num / r_num
                 end  
    end
;;

(********************************
* Use effect handler to mimic
* monad transformers
********************************)
 
let arithmeticHandler = handler
    | #Arith_DivByZero () k ->  -1 (* (absurd (#DivisionByZero ())) *)

;; 

(********************************
* Big Test
********************************)

let addCase =
    Add (
        Add (
            Add (
                (Num 20),
                (Num 2)
            ),
            Mul (
                (Num 1),
                (Num 2)
            )
        ),
        Sub (
            Add (
                (Num 2),
                (Num 2)
            ),
            Add (
                (Num 1),
                (Num 2)
            )
        )
    );;

let rec createCase n =
    begin match n with
    | 1 -> (Div (Num 100,Num 10))
    | _ -> Add( addCase, (createCase (n-1)))
    end;;

let finalCase = createCase 200;;

let bigTest () =
     with arithmeticHandler handle (
            interp (finalCase))


